<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>平衡树总结</title>
    <url>/2019/11/24/%E5%B9%B3%E8%A1%A1%E6%A0%91%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><!-- build time:Sat Dec 14 2019 14:25:40 GMT+0800 (GMT+08:00) --><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>[ORDER]关于休整信息学奥赛学习进程的命令</title>
    <url>/2019/11/16/ORDER-ExceptionSolution/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><script src="https://ajax.aspnetcdn.com/ajax/jQuery/jquery-3.4.1.min.js"></script>
<div id="hbe-security">
  <div class="hbe-input-container">
  <input type="password" class="hbe-form-control" id="pass" placeholder="弗输入密码,不得视邪" />
    <label for="pass">弗输入密码,不得视邪</label>
    <div class="bottom-line"></div>
  </div>
</div>
<div id="decryptionError" style="display: none;">Incorrect Password!</div>
<div id="noContentError" style="display: none;">No content to display!</div>
<div id="encrypt-blog" style="display:none">
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
</div>
<script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>学习计划</tag>
      </tags>
  </entry>
  <entry>
    <title>疫情控制做题记</title>
    <url>/2019/11/09/PN-YiQingKongZhi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><!-- build time:Sat Dec 14 2019 14:25:40 GMT+0800 (GMT+08:00) --><blockquote><p>题目来源:<a href="https://www.luogu.org/problem/P1084" target="_blank" rel="noopener"><i class="fa fa-send-o"></i>洛谷</a></p></blockquote><p>大意:有带权树一,令自根至每叶子路上至少驻军一(可在叶子之上而不可在根),初始有些节点上有军队,求所有军队移动距离最大值的最小值</p><a id="more"></a><p>等会儿,”最大值的最小值”?,看上去像二分答案(看来总结大意还是很重要的)</p><p><del>余思良久,但以为DP,总结大意乃知二分答案.故知总结大意之要也</del></p><p>细节:$w&lt;1e9$,则开long long</p><p>以$l=0,r=最长链(或以路径总和代之) $为边界,枚举移动距离之上界,贪心判断,原则如下:</p><p>dfs根的每一个儿子之原则有:</p><ul><li>一个军队,能向上调就调(只要不超上界),因为越向上,能覆盖的叶子节点一般会增多(也有可能不变),永远不要向下调兵,因此其调兵过程中任一一个子树不会出现其他子树的军队</li></ul><p>dfs完根的每一个儿子,如果有$u$的子树未完全覆盖,那对于这颗子树,它之前自己的规划就完全不要了;而把其他的子树有多出来的剩余里程数$&gt;0$的军队,看看够不够经过根节点跑到$u$的;如果够,就调到$u$去.</p><p>于是模拟过程分:</p><p>1.$O(N)$预处理出每个节点到根的距离</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dfs1(u,road)&#123;</span><br><span class="line">    dis[u]=road;</span><br><span class="line">    <span class="keyword">for</span>(v in son[u])</span><br><span class="line">	&#123;</span><br><span class="line">		dfs1(v,road+E(u,v))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺便预处理出每个军队</p><p>2.dfs根的每一个儿子$u$</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dfs2(u)&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=arrmy[u]?mid:<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(v in son[u])</span><br><span class="line">	&#123;</span><br><span class="line">		ans=max(ans,dfs2(v)-E(u,v));</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.如果$dfs(u)&lt;0$,则其子树未完全覆盖,把其他多出来的军队调过去,然后</p><p><strong><font color="purple">Runtime Error:栈溢出[&gt;1 Byte],此思维进程IS KILLED</font></strong></p><hr><p><strong><font color="red">正在查找其他可行解<del>(查看题解)</del>…</font></strong></p><ol><li>O(N)倍增预处理出祖先和距离</li><li>O(M)的每个军队向上往死里跳</li><li>O(N)审查无法自保的子树</li><li>每一个能自保的根之子,留一个里程最小的军队,其他军队开赴根节点</li><li>根节点统一调控,以贪心法把军队驻扎在无法自保的根之子去</li></ol><!-- rebuild by neat -->]]></content>
      <categories>
        <category>做题记</category>
      </categories>
  </entry>
  <entry>
    <title>日志汇总</title>
    <url>/2019/11/02/CC-Main-File/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><script src="https://ajax.aspnetcdn.com/ajax/jQuery/jquery-3.4.1.min.js"></script>
<div id="hbe-security">
  <div class="hbe-input-container">
  <input type="password" class="hbe-form-control" id="pass" placeholder="弗输入密码,不得视邪" />
    <label for="pass">弗输入密码,不得视邪</label>
    <div class="bottom-line"></div>
  </div>
</div>
<div id="decryptionError" style="display: none;">Incorrect Password!</div>
<div id="noContentError" style="display: none;">No content to display!</div>
<div id="encrypt-blog" style="display:none">
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
</div>
<script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>4294967280</tag>
      </tags>
  </entry>
  <entry>
    <title>(未完)[NOIP2018]换教室做题笔记</title>
    <url>/2019/10/28/PN-NOIP2016-Classroom/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><!-- build time:Sat Dec 14 2019 14:25:40 GMT+0800 (GMT+08:00) --><a id="more"></a><h1 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h1><p>由题面”最短路”和”$v\leq300$”可知,需要Floyd处理</p><p>对第$i$节课来说,有如下情况</p><p><img src="/images/loading.png" data-original="情况.jpg" alt="情况"></p><p><strong>其中方括号表示取两种情况的最小值(需要提前确定选不选,不存在概率问题)</strong></p><p><strong>尖括号表示两种情况成以相应概率后相加(未发生的,未确定的事件,概率之和为1)</strong></p><p>我们可以把红圈里的分支继续完善,such as</p><p><img src="/images/loading.png" data-original="情况2.jpg" alt="情况2"></p><p>注意把”被遗弃”的两个$cost$再分别乘以它们的概率</p><p>于是有$f[i][j][state]$表示前$i$节课,换了$j$节,第$i$节换不换(即$state$)是的最小期望</p><p><del>假装我说明白了吧</del></p><h1 id="修正模型2"><a href="#修正模型2" class="headerlink" title="修正模型2"></a>修正模型2</h1><!-- rebuild by neat -->]]></content>
      <categories>
        <category>做题笔记</category>
        <category>NOIP2016</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title>(未完)[NOIP2018]保卫王国做题笔记</title>
    <url>/2019/10/27/PN-NOIP2018-KingdomProtection/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><!-- build time:Sat Dec 14 2019 14:25:40 GMT+0800 (GMT+08:00) --><a id="more"></a><h1 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h1><h2 id="Part-1"><a href="#Part-1" class="headerlink" title="Part 1"></a>Part 1</h2><p>树上DP,设$dp[i][state(state=0或1)]$是$i$结点时为$state$时,以$i$为根的子树最少花费,则有</p><script type="math/tex;mode=display">dp[u][0]=\sum_{E(u,v)}dp[v][1]\\
dp[u][1]=\sum_{E(u,b)}\min(dp[v][0],dp[v][1])</script><p>对于每一组询问($i$必须为$a$,$j$必须为$b$),使$dp[i][!a]=dp[j][!b]=INF$即可</p><h2 id="Part-2"><a href="#Part-2" class="headerlink" title="Part 2"></a>Part 2</h2><p>发现每次询问,都只有从$Root$分别到$i$和$j$的两条链上的结点$dp$值有变动,即从$Root$到$LCA(i,j)$,$LCA(i,j)$分别到$i$和$j$三条链上有变动,于是不需大量修改</p><blockquote><p>倍增法</p></blockquote><p>提前倍增预处理出$f[i][k][a][b]$表示$i$结点为$a$,$i$的第$2^k$个祖先为$b$时,除去$i$的子树及$i$,以$i$的第$2^k$个祖先为根的最小花费</p><script type="math/tex;mode=display">fa是i的父节点\\
f[i][0][1][0]=dp[fa][0]-dp[i][1]\\
f[i][0][1][1]=f[i][0][0][1]=f[i][dp[fa][1]-\min(dp[i][0],dp[i][1])\\</script><script type="math/tex;mode=display">fa(i,k)表示i的第k个祖先\\
f[i][k][a][b]=\min(f[i][k-1][a][0]+f[fa(i,k-1)][0][b],\\f[i][k-1][a][1]+f[fa(i,k-1)][1][b])</script><p>然后按LCA的模式处理询问即可</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>做题笔记</category>
        <category>NOIP2018</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title>The Renovation of The Blog</title>
    <url>/2019/10/27/About-The-Renovation-of-Blog/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><!-- build time:Sat Dec 14 2019 14:25:40 GMT+0800 (GMT+08:00) --><p>此博客已翻新完毕于2019.10.27,旧文档尚未就位,博客优化进程终止</p><a id="more"></a><hr><p>为防止博客优化进程消耗精力,影响学习主进程及第三轮攻势,于2019.10.26至2020.7.1之间全面终止博客优化进程并禁止重启</p><blockquote><p>中央委员会批示</p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>BLOG</tag>
      </tags>
  </entry>
  <entry>
    <title>[题目学习笔记]SSOIER1726_矩阵</title>
    <url>/2019/08/18/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-SSOIER1726-%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><!-- build time:Sat Dec 14 2019 14:25:40 GMT+0800 (GMT+08:00) --><h1 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h1><p>设第$i$行总共统一加了$Add1[i]$,第$j$列总共统一加了$Add2[j]$</p><p>则对于格子$[i][j]$,其值为$Add1[i]+Add2[j]$</p><p>于是对于每一组限制$(x,y,c)$,有$Add1[x]+Add2[y]=c$</p><p>差分约束的关系式是$x-y\leq or\geq c$怎么办,那么<strong>强行</strong>设$FAdd2[y]=-Add2[y]</p><p>于是对于每一组限制$(x,y,c)$,有$Add1[x]-FAdd2[y]=c$$</p><p>即$Add1[x]-FAdd2[y]\geq c\\FAdd2[y]-Add1[x]\geq -c$</p><p>DFS_SPFA判环即可</p><h1 id="DEBUG"><a href="#DEBUG" class="headerlink" title="DEBUG"></a>DEBUG</h1><p>又忘了$InStack[i]=0$QwQ<br>清空图时又忘了$SCount=0$QwQ<br></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> N,M,K;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">2e3</span>+<span class="number">10</span>,MAXM=<span class="number">4e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> SHd[MAXN],SNxt[MAXM],STo[MAXM],SDis[MAXM],SCount;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> to,<span class="keyword">int</span> dis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SCount++;</span><br><span class="line">	SNxt[SCount]=SHd[from];</span><br><span class="line">	STo[SCount]=to,SDis[SCount]=dis;</span><br><span class="line">	SHd[from]=SCount;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> Dis[MAXN];</span><br><span class="line"><span class="keyword">int</span> Vis[MAXN],InStack[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Vis[x]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(InStack[x])<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	InStack[x]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=SHd[x];i;i=SNxt[i])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v=STo[i];</span><br><span class="line">		<span class="keyword">if</span>(Dis[v]&lt;Dis[x]+SDis[i])</span><br><span class="line">		&#123;</span><br><span class="line">			Dis[v]=SDis[i]+Dis[x];</span><br><span class="line">			<span class="keyword">if</span>(!SPFA(v))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	InStack[x]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> _main()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">memset</span>(SHd,<span class="number">0</span>,<span class="keyword">sizeof</span>(SHd));</span><br><span class="line">	<span class="built_in">memset</span>(Vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(Vis));</span><br><span class="line">	<span class="built_in">memset</span>(InStack,<span class="number">0</span>,<span class="keyword">sizeof</span>(InStack));</span><br><span class="line">	SCount=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;N,&amp;M,&amp;K) ;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=K;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> x,y,c;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;c);</span><br><span class="line">		AddEdge(y+N,x,c);</span><br><span class="line">		AddEdge(x,y+N,-c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(Dis,<span class="number">0xC0</span>,<span class="keyword">sizeof</span>(Dis));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N+M;i++)<span class="keyword">if</span>(!Vis[i])</span><br><span class="line">	&#123;</span><br><span class="line">		Dis[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(!SPFA(i))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">	<span class="keyword">while</span>(T--)_main();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>[题目学习笔记]账本核算</title>
    <url>/2019/08/17/%E9%A2%98%E7%9B%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%B4%A6%E6%9C%AC%E6%A0%B8%E7%AE%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><!-- build time:Sat Dec 14 2019 14:25:40 GMT+0800 (GMT+08:00) --><h1 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h1><p>差分约束</p><p>设前$i$月总收入为$S[i]$</p><p>则对于每一组($x,y,w$),有$S[y]-S[x-1]=w$</p><p>即关系式为</p><script type="math/tex;mode=display">\color{red}S[y]-S[x-1]\geq w\\
S[y]-S[x-1]\leq w,即\color{red}s[x-1]-s[y]\geq -w</script><p>然而诡异的时说好的$N,M\leq100$然而却RE(IN SSOIER.com)</p><p>随手开到$1e3$而AC</p><p><del>当然也有可能是我太弱了</del></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">int</span> N,M;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">1000</span>+<span class="number">10</span>,MAXM=<span class="number">2000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> SHd[MAXN],SNxt[MAXM],STo[MAXM],SDis[MAXM],SCount;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> to,<span class="keyword">int</span> dis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SCount++;</span><br><span class="line">	SNxt[SCount]=SHd[from];</span><br><span class="line">	STo[SCount]=to,SDis[SCount]=dis;</span><br><span class="line">	SHd[from]=SCount;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll Dis[MAXN];</span><br><span class="line"><span class="keyword">int</span> InStack[MAXN],Vis[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Vis[x]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(InStack[x])<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	InStack[x]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=SHd[x];i!=<span class="number">-1</span>;i=SNxt[i])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v=STo[i];</span><br><span class="line">		<span class="keyword">if</span>(Dis[v]&lt;(ll)Dis[x]+SDis[i])</span><br><span class="line">		&#123;</span><br><span class="line">			Dis[v]=(ll)Dis[x]+SDis[i];</span><br><span class="line">			<span class="keyword">if</span>(!SPFA(v))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	InStack[x]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(SHd,<span class="number">-1</span>,<span class="keyword">sizeof</span>(SHd));</span><br><span class="line">		SCount=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;M);</span><br><span class="line">		<span class="built_in">memset</span>(Dis,<span class="number">0xC0</span>,<span class="keyword">sizeof</span>(Dis));</span><br><span class="line">		<span class="built_in">memset</span>(Vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(Vis));</span><br><span class="line">		<span class="built_in">memset</span>(InStack,<span class="number">0</span>,<span class="keyword">sizeof</span>(InStack));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> X,Y,W;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;X,&amp;Y,&amp;W);</span><br><span class="line">			AddEdge(X<span class="number">-1</span>,Y,W),AddEdge(Y,X<span class="number">-1</span>,-W);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)<span class="keyword">if</span>(!InStack[i])</span><br><span class="line">		&#123;</span><br><span class="line">			Dis[i]=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span>(!SPFA(i))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">puts</span>(<span class="string">"false"</span>);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">"true"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">	<span class="keyword">while</span>(T--)Work();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>[题目学习笔记]小k的农场</title>
    <url>/2019/08/17/%E9%A2%98%E7%9B%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%B0%8Fk%E7%9A%84%E5%86%9C%E5%9C%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><!-- build time:Sat Dec 14 2019 14:25:40 GMT+0800 (GMT+08:00) --><p>差分约束判环<br>设$D[i]$表示第$i$个的农作物数量,则关系式</p><script type="math/tex;mode=display">D[a]-D[b]\geq c\\
D[a]-D[b]\leq c,即D[b]-D[a]\geq -c\\
D[a]-D[b]=0,即D[a]-D[b]\geq 0\&\&D[b]-D[a]\geq 0</script><p>然BFS_SPFA炸了,于是DFS_SPFA<br></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> N,M;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>,MAXM=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> SHd[MAXN],SNxt[MAXM*<span class="number">2</span>],SDis[MAXM*<span class="number">2</span>],STo[MAXM*<span class="number">2</span>],SCount;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> Dis[MAXN];</span><br><span class="line"><span class="keyword">int</span> Vis[MAXN],VisCount[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> to,<span class="keyword">int</span> dis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SCount++;</span><br><span class="line">	SNxt[SCount]=SHd[from];</span><br><span class="line">	SDis[SCount]=dis,STo[SCount]=to;</span><br><span class="line">	SHd[from]=SCount;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	VisCount[x]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(Vis[x])<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	Vis[x]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=SHd[x];i;i=SNxt[i])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v=STo[i];</span><br><span class="line">		<span class="keyword">if</span>(Dis[v]&lt;Dis[x]+SDis[i])</span><br><span class="line">		&#123;</span><br><span class="line">			Dis[v]=Dis[x]+SDis[i];</span><br><span class="line">			<span class="keyword">if</span>(!SPFA(v))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	Vis[x]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS_SPFA</span><span class="params">(<span class="keyword">int</span> Start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;Q;</span><br><span class="line">	Q.push(Start);</span><br><span class="line">	Dis[Start]=<span class="number">0</span>;Vis[Start]=VisCount[Start]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!Q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> u=Q.front();</span><br><span class="line">		Q.pop();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=SHd[u];i;i=SNxt[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> v=STo[i];</span><br><span class="line">			<span class="keyword">if</span>(Dis[v]&lt;Dis[u]+SDis[i])</span><br><span class="line">			&#123;</span><br><span class="line">				Dis[v]=Dis[u]+SDis[i];</span><br><span class="line">				<span class="keyword">if</span>(Vis[v])<span class="keyword">continue</span>;</span><br><span class="line">				<span class="keyword">if</span>(++VisCount[v]&gt;N+<span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">				Q.push(v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;M);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> order,a,b,c;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;order,&amp;a,&amp;b);</span><br><span class="line">		<span class="keyword">switch</span>(order)&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:&#123;</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;c);</span><br><span class="line">				AddEdge(b,a,c);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>:&#123;</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;c);</span><br><span class="line">				AddEdge(a,b,-c);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span>:&#123;</span><br><span class="line">				AddEdge(a,b,<span class="number">0</span>),AddEdge(b,a,<span class="number">0</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(Dis,<span class="number">0Xc0</span>,<span class="keyword">sizeof</span>(Dis));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)<span class="keyword">if</span>(!VisCount[i])<span class="keyword">if</span>(!SPFA(i))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>[题目学习笔记]LOJ10090_布局</title>
    <url>/2019/08/17/%E9%A2%98%E7%9B%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-LOJ10090-%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><!-- build time:Sat Dec 14 2019 14:25:40 GMT+0800 (GMT+08:00) --><p>差分约束<br>条件:($P[i]$为第$i$头奶牛位置)</p><script type="math/tex;mode=display">P[B]-P[A]\leq D\\
P[A]-P[B]\leq -D\\
P[i-1]-P[i]\leq 0\\</script><p>求最短路即可,若SPFA(1)时访问不到N,则输出-2;若负环则输出-1.<br><del>SPFA忘了Vis[u]=0这一句,结果调试了2个小时QwQ,于是乎又双叒叕证明了信息学学习准则草案的无比正确性</del><br></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> N,ML,MD;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">1e3</span>+<span class="number">10</span>,MAXM=<span class="number">3e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> SHd[MAXN],SNxt[MAXM] ,STo[MAXM],SDis[MAXM],SCount;</span><br><span class="line">ll Dis[MAXN];</span><br><span class="line"><span class="keyword">int</span> Vis[MAXN],VisCount[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> to,<span class="keyword">int</span> dis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SCount++;</span><br><span class="line">	SNxt[SCount]=SHd[from];</span><br><span class="line">	SDis[SCount]=dis,STo[SCount]=to;</span><br><span class="line">	SHd[from]=SCount;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;Q;</span><br><span class="line">	Q.push(start);</span><br><span class="line">	Dis[start]=<span class="number">0</span>,Vis[start]=VisCount[start]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!Q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> u=Q.front();</span><br><span class="line">		Q.pop();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=SHd[u];i;i=SNxt[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> v=STo[i];</span><br><span class="line">			<span class="keyword">if</span>(Dis[v]&gt;SDis[i]+Dis[u])</span><br><span class="line">			&#123;</span><br><span class="line">				Dis[v]=SDis[i]+Dis[u];</span><br><span class="line">				<span class="keyword">if</span>(Vis[v])<span class="keyword">continue</span>;</span><br><span class="line">				VisCount[v]++;</span><br><span class="line">				<span class="keyword">if</span>(VisCount[v]&gt;N+<span class="number">1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				Q.push(v),Vis[v]=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		Vis[u]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ABS</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;<span class="number">0</span>)<span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;N,&amp;ML,&amp;MD);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ML;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> A,B,D;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;A,&amp;B,&amp;D);</span><br><span class="line">		AddEdge(A,B,D);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=MD;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> A,B,D;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;A,&amp;B,&amp;D);</span><br><span class="line">		AddEdge(B,A,-D);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=N;i++)AddEdge(i,i<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">bool</span> Flag;</span><br><span class="line">	<span class="built_in">memset</span>(Dis,<span class="number">0x7f</span>,<span class="keyword">sizeof</span>(Dis));</span><br><span class="line">	<span class="keyword">if</span>(!SPFA(<span class="number">1</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		Flag=VisCount[N]&gt;<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=N;i++)<span class="keyword">if</span>(!VisCount[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!SPFA(i))&#123;</span><br><span class="line">				<span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(Flag)<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,Dis[N]-Dis[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"-2"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>[题目学习笔记]LOJ10089_糖果</title>
    <url>/2019/08/17/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-LOJ10089-%E7%B3%96%E6%9E%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><!-- build time:Sat Dec 14 2019 14:25:40 GMT+0800 (GMT+08:00) --><h1 id="模型构造"><a href="#模型构造" class="headerlink" title="模型构造"></a>模型构造</h1><p>差分约束</p><p>设$Dis[i]$为编号为$i$的小朋友的获得糖果数</p><p>则</p><script type="math/tex;mode=display">X=1:\ D[A]-D[B]\geq 0,D[B]-D[A] \geq 0\\
X=2:\ D[A]-D[B]\geq 1\\
X=3:\ D[A]-D[B] \geq 0\\
X=4:\ D[A]-D[B]\geq1\\
X=5:\ D[B]-D[A]\geq 0</script><p>有正环则无解</p><p>由于图不一定联通,每次以一个未访问结点$start$为起点SPFA</p><p>因为每个小朋友至少要有1颗糖,$Dis[start]=1$</p><h1 id="模型修正1"><a href="#模型修正1" class="headerlink" title="模型修正1"></a>模型修正1</h1><p>答案可能超过int_MAX,开long long</p><h1 id="模型修正2"><a href="#模型修正2" class="headerlink" title="模型修正2"></a>模型修正2</h1><p>加入特判,当$(X==2 ||X==3)\&amp;\&amp;(A==B)$时非法</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N,K;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>,MAXK=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> SHd[MAXN],SNxt[MAXK*<span class="number">2</span>],STo[MAXK*<span class="number">2</span>],SDis[MAXK*<span class="number">2</span>],SCount;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> to,<span class="keyword">int</span> dis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SCount++;</span><br><span class="line">	SNxt[SCount]=SHd[from];</span><br><span class="line">	STo[SCount]=to,SDis[SCount]=dis;</span><br><span class="line">	SHd[from]=SCount;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Vis[MAXN],VisCount[MAXN];</span><br><span class="line">ll Dis[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> Start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	Dis[Start]=<span class="number">1</span>;Vis[Start]=VisCount[Start]=<span class="number">1</span>;</span><br><span class="line">	Q.push(Start);</span><br><span class="line">	<span class="keyword">while</span>(!Q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> u=Q.front();</span><br><span class="line">		Q.pop();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=SHd[u];i;i=SNxt[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(Dis[STo[i]]&lt;(ll)SDis[i]+Dis[u])</span><br><span class="line">			&#123;</span><br><span class="line">				Dis[STo[i]]=(ll)SDis[i]+Dis[u];</span><br><span class="line">				<span class="keyword">if</span>(Vis[STo[i]])<span class="keyword">continue</span>;</span><br><span class="line">				VisCount[STo[i]]++;</span><br><span class="line">				<span class="keyword">if</span>(VisCount[STo[i]]&gt;N+<span class="number">1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				Q.push(STo[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		Vis[u]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;K);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=K;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> X,A,B;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;X,&amp;A,&amp;B);</span><br><span class="line">		<span class="keyword">switch</span>(X)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:&#123;</span><br><span class="line">				AddEdge(B,A,<span class="number">0</span>),AddEdge(A,B,<span class="number">0</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>:&#123;</span><br><span class="line">				<span class="keyword">if</span>(A==B)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">puts</span>(<span class="string">"-1"</span>) ;</span><br><span class="line">					<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				AddEdge(A,B,<span class="number">1</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span>:&#123;</span><br><span class="line">				AddEdge(B,A,<span class="number">0</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">4</span>:&#123;</span><br><span class="line">				<span class="keyword">if</span>(A==B)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">puts</span>(<span class="string">"-1"</span>) ;</span><br><span class="line">					<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				AddEdge(B,A,<span class="number">1</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">5</span>:&#123;</span><br><span class="line">				AddEdge(A,B,<span class="number">0</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(Dis,<span class="number">0xC0</span>,<span class="keyword">sizeof</span>(Dis));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)<span class="keyword">if</span>(!VisCount[i])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!SPFA(i))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ll Ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Ans+=Dis[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,Ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>[题目学习笔记]LOJ10088_收纳员问题</title>
    <url>/2019/08/17/%E9%A2%98%E7%9B%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-LOJ10088-%E6%94%B6%E7%BA%B3%E5%91%98%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><!-- build time:Sat Dec 14 2019 14:25:40 GMT+0800 (GMT+08:00) --><p><del>本文思路依旧照搬一本通</del></p><p>差分约束</p><p>设$num[i]$为$i$时刻申请开始工作的人数,$x[i]$为$i$时刻实际开始工作的人数则$x[i]\leq num[i]$,$r[i]$表示$i$时刻需要有多少人工作</p><p>设</p><script type="math/tex;mode=display">s[i]=\sum_{j=1}^ix[i]</script><p>则$i$时刻工作的总人数为$s[i]-s[i-8]$</p><p>故知</p><script type="math/tex;mode=display">s[i]-s[i-8]\geq r[i](i\in[8,23])\\
Especially,s[23]+s[i]-s[i+16]\geq r[i](i\in [0,7])\\
0\leq s[i]-s[i-1]\leq num[i](i\in [1,23])\\
\color{green}{Especially,0\leq s[0]-s[23]\leq num[0]}\\</script><p>则</p><script type="math/tex;mode=display">s[i]-s[i-8]\geq r[i](i\in[8,23])\\
\color{red}{s[i]-s[i+16]\geq r[i]-s[23](i\in [0,7])}\\
s[i]-s[i-1]\geq 0(i\in[0,23])\\
s[i-1]-s[i]\geq -num[i](i\in[0,23])\\
\color{green}{s[0]-s[23]\geq 0\\
s[23]-s[0]\geq -num[0]\\}</script><p><strong>20190817更正</strong></p><p><strong>绿色关系式是错误的,不应加入差分系统(因为$S[0]\not\geq S[23]$)</strong></p><p>红色关系式中,有三个未知量,则枚举$s[23]$可能的值,可行时输出最小值即可</p><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>[题目学习笔记]LOJ10087_Intervals</title>
    <url>/2019/08/16/LOJ10087-Intervals/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><!-- build time:Sat Dec 14 2019 14:25:40 GMT+0800 (GMT+08:00) --><p>差分约束,其约束条件:<br>$S[b]-S[a-1]\geq c$</p><p>$S[i]-S[i-1]\geq 0$</p><p>$S[i]-S[i-1]\leq 1,即S[i-1]-S[i]\geq -1$</p><p>代码如下<br><a id="more"></a></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">5e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> SHd[(<span class="keyword">int</span>)<span class="number">5e4</span>+<span class="number">10</span>],SNxt[(<span class="keyword">int</span>)<span class="number">1e5</span>+MAXN],STo[(<span class="keyword">int</span>)<span class="number">1e5</span>+MAXN],SDis[(<span class="keyword">int</span>)<span class="number">1e5</span>+MAXN],SCount;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> to,<span class="keyword">int</span> dis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SNxt[++SCount]=SHd[from];</span><br><span class="line">	STo[SCount]=to,SDis[SCount]=dis;</span><br><span class="line">	SHd[from]=SCount;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> Minn,Maxx;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;Q;</span><br><span class="line"><span class="keyword">int</span> Dis[MAXN],Vis[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Q.push(x);</span><br><span class="line">	Vis[x]=<span class="number">1</span>;</span><br><span class="line">	Dis[x]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!Q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> u=Q.front();</span><br><span class="line">		Q.pop();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=SHd[u];i!=<span class="number">-1</span>;i=SNxt[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(Dis[u]+SDis[i]&gt;Dis[STo[i]])</span><br><span class="line">			&#123;</span><br><span class="line">				Dis[STo[i]]=Dis[u]+SDis[i];</span><br><span class="line">				<span class="keyword">if</span>(!Vis[STo[i]])</span><br><span class="line">				&#123;</span><br><span class="line">					Vis[STo[i]]=<span class="number">1</span>;</span><br><span class="line">					Q.push(STo[i]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		Vis[u]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">memset</span>(SHd,<span class="number">-1</span>,<span class="keyword">sizeof</span>(SHd)) ;</span><br><span class="line">	<span class="built_in">memset</span>(SNxt,<span class="number">-1</span>,<span class="keyword">sizeof</span>(SNxt));</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123; </span><br><span class="line">		<span class="keyword">int</span> a,b,c;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">		AddEdge(a,b+<span class="number">1</span>,c);</span><br><span class="line">		Minn=<span class="built_in">std</span>::min(Minn,a),Maxx=<span class="built_in">std</span>::max(Maxx,b+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(Dis,<span class="number">0xC0</span>,<span class="keyword">sizeof</span>(Dis));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=Minn;i&lt;=Maxx;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		AddEdge(i,i+<span class="number">1</span>,<span class="number">0</span>),AddEdge(i+<span class="number">1</span>,i,<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	SPFA(Minn);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Dis[Maxx]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>题目学习笔记</category>
        <category>图论</category>
        <category>差分约束</category>
      </categories>
      <tags>
        <tag>一本通</tag>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串算法</title>
    <url>/2019/08/04/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95%E4%B9%8B%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><!-- build time:Sat Dec 14 2019 14:25:40 GMT+0800 (GMT+08:00) --><p>字符串Hash</p><p>字符串Hash就是将一个字符串转换成b进制数,这样比较字符串就和比较数字一样方便了<br>(如可以知道”ABC”==”ABC”,”BC”是”ABCD”的一部分)<br>为防止溢出,通常将$Hash mod h(b&lt;h\&amp;\&amp;\gcd(b,h)=1)$<br>则$H(String,k)=(H(String,k-1)*b+String[k]) mod h$</p><h1 id="Hash表-演示插入377的过程"><a href="#Hash表-演示插入377的过程" class="headerlink" title="Hash表(演示插入377的过程)"></a>Hash表(演示插入377的过程)</h1><p><img src="/images/loading.png" data-original="0.png" alt><br><img src="/images/loading.png" data-original="1.png" alt><br><img src="/images/loading.png" data-original="2.png" alt></p><h1 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h1><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法学习</category>
        <category>字符串算法</category>
      </categories>
      <tags>
        <tag>字符串算法</tag>
      </tags>
  </entry>
  <entry>
    <title>P1273有线电视网之题解</title>
    <url>/2019/08/03/P1273%E6%9C%89%E7%BA%BF%E7%94%B5%E8%A7%86%E7%BD%91%E4%B9%8B%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><!-- build time:Sat Dec 14 2019 14:25:40 GMT+0800 (GMT+08:00) --><p>原题地址[<a href="https://www.luogu.org/problem/P1273" target="_blank" rel="noopener">https://www.luogu.org/problem/P1273</a>].</p><p>本题看上去像是普通的树上背包，然而不同的是除了考虑的范围，费用还出现了收入，于是我们对不和谐的地方进行”整编”.</p><h4 id="模拟部分"><a href="#模拟部分" class="headerlink" title="模拟部分"></a>模拟部分</h4><p>有一些用户所支付的费用，大于公司修路所用的费用，则公司盈利；然而有一些用户支付的费用不足以用来修路，就需要公司挪用一部分盈利额来补贴。我们可以把问题转化为，用盈利额，最多能帮助多少修不起路的用户看上电视。</p><p>这个问题的关键是盈利额是固定的（不可能存在你给修得起路的用户修路你还亏钱的情况，只能是既得到了盈利额，路又修好了）它可以递归算出:</p><p>首先,我们假设用户都是预付款。用户把钱交给上一级转播站（父节点）。转播站花钱把路修好。剩下的钱都累积到转播站的私有财产了。这一级别的转播站在把钱交给上一级的转播站（父节点）。上一级的转播站把路修好剩下的钱又累积进私有财产……直到我交的钱不够修路了，就把钱留在自己手里，等待上面的补贴.就这样,盈利逐级收归中央,而有一些资产在传递的过程中出现残留.</p><p>这个过程的伪代码如下</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> TMoney[MAXN];<span class="comment">//TMoney[x]代表x的资产</span></span><br><span class="line">Dfs(x)</span><br><span class="line">	<span class="keyword">if</span>(N-M&lt;x)</span><br><span class="line">		TMoney[x]=Value[x];<span class="comment">//Value为用户支付金额</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">for</span>(every E(x,v))</span><br><span class="line">		Dfs(v);</span><br><span class="line">		<span class="keyword">if</span>(TMoney[v]&gt;=E(x,v))</span><br><span class="line">			TMoney[x]+=TMoney[v]-E(x,v);</span><br></pre></td></tr></table></figure><h4 id="动规部分"><a href="#动规部分" class="headerlink" title="动规部分"></a>动规部分</h4><p>求出盈利额后，我们把修得起路的用户从动态规划的范围内彻底排除，然后就可以进行树上背包了.</p><p>设$f[x][s]$是以x结点为根的子树接受上级s元的补贴,最多能帮助多少修不起路的用户看上电视,</p><p>则$f[x][s]=\max\{f[v][j-E(x,v)]+f[x][s-j]\}(v\in son[i])$,这里的$E(i,v)$表示修好$(i,v)$这条边还需要补贴多少.</p><p>这个过程的伪代码如下</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Dp(x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(到了修不起路的叶子)</span><br><span class="line">        f[x][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(every E(x,v))</span><br><span class="line">	&#123;</span><br><span class="line">		Dp(v);</span><br><span class="line">		<span class="keyword">for</span>(非负整数s)<span class="comment">//范围见后文</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=s;j&gt;=E(x,v);j--)</span><br><span class="line">			&#123;</span><br><span class="line">				f[x][s]=<span class="built_in">std</span>::max(f[x][s],f[x][s-j]+f[v][j-E(x,v)]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了方便，我们在前面模拟时:如果我的资产够修路，那$上一级的资产总额+=我的资产-E(i,v),E(i,v)=0$,如果不够,就把我的资产全部用来投入修路,即$E(i,v)-=我的资产,我的资产=0$</p><p>还有一些问题:伪代码中s的范围应该是多少?显然不会超过总盈利额，即根节点的资产(其他节点的资产修路的时候都花光了).并且，如果$CS[i]$元能修好整个子树的路，那么大于$CS[i]$的补贴也毫无意义.</p><p>于是,$0\leq s\leq \min(z,TMoney[1])$</p><p>最后统计答案时,不要忘了加上修得起路的用户数</p><p>所以在前面模拟的部分，我们还需要递归求出这些值</p><p>代码</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N,M;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAXN =<span class="number">3e3</span>+<span class="number">10</span>,MAXM=<span class="number">3e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> StarHd[MAXN],StarNxt[MAXN],StarTo[MAXN],StarDis[MAXN],StarCount;</span><br><span class="line"><span class="keyword">int</span> Value[MAXN];</span><br><span class="line"><span class="keyword">int</span> f[MAXN][<span class="number">10000</span>];</span><br><span class="line"><span class="keyword">int</span> Amazing;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x)\</span></span><br><span class="line">&#123;\</span><br><span class="line">	<span class="built_in">printf</span>(#x);\</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"=%d\n"</span>,x);\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> to,<span class="keyword">int</span> dis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	StarCount++;</span><br><span class="line">	StarNxt[StarCount]=StarHd[from];</span><br><span class="line">	StarTo[StarCount]=to;</span><br><span class="line">	StarDis[StarCount]=dis;</span><br><span class="line">	StarHd[from]=StarCount; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;M);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N-M;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> k;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line">		<span class="keyword">while</span>(k--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> a,b;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">			AddEdge(i,a,b);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=N-M+<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,Value+i);</span><br><span class="line">		Amazing+=Value[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> TMoney[MAXN],TSum[MAXN],TFlag[MAXN];<span class="comment">//T=Treasure</span></span><br><span class="line"><span class="keyword">int</span> CS[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(N-M&lt;x)</span><br><span class="line">	&#123;</span><br><span class="line">		TMoney[x]=Value[x];</span><br><span class="line">		TSum[x]=<span class="number">1</span>;</span><br><span class="line">		<span class="comment">//CS[x]=0;Value[x];</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=StarHd[x];i;i=StarNxt[i])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v=StarTo[i];</span><br><span class="line">		Dfs(v);</span><br><span class="line">		CS[x]+=StarDis[i]+CS[v];</span><br><span class="line">		<span class="keyword">if</span>(TMoney[v]&gt;=StarDis[i])</span><br><span class="line">		&#123;</span><br><span class="line">			TMoney[x]+=TMoney[v]-StarDis[i];</span><br><span class="line">			TSum[x]+=TSum[v];</span><br><span class="line">			TFlag[v]=<span class="number">1</span>;</span><br><span class="line">			StarDis[i] =<span class="number">0</span>;</span><br><span class="line">			TMoney[v]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;StarDis[i]-=TMoney[v];TMoney[v]=<span class="number">0</span>;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dp</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CS[x]-=(!TFlag[x])?TSum[x]:<span class="number">0</span>;</span><br><span class="line">	CS[x]=<span class="built_in">std</span>::min(CS[x],TMoney[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">if</span>(N-M&lt;x)</span><br><span class="line">	&#123;</span><br><span class="line">		f[x][<span class="number">0</span>]=!TFlag[x];</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> s=TMoney[<span class="number">1</span>];s&gt;=<span class="number">0</span>;s--)f[x][s]+=(!TFlag[x])?TSum[x]:<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=StarHd[x];i;i=StarNxt[i])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v=StarTo[i];</span><br><span class="line">		Dp(v);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> s=CS[x];s&gt;=<span class="number">0</span>;s--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=s;j&gt;=StarDis[i];j--)</span><br><span class="line">			&#123;</span><br><span class="line">				f[x][s]=<span class="built_in">std</span>::max(f[x][s],f[x][s-j]+f[v][j-StarDis[i]]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Read();</span><br><span class="line">	Dfs(<span class="number">1</span>);</span><br><span class="line">	Dp(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> Ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=TMoney[<span class="number">1</span>];i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Ans=<span class="built_in">std</span>::max(Ans,f[<span class="number">1</span>][i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>题目练习</category>
        <category>简单动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>二分之边界</title>
    <url>/2019/08/03/%E4%BA%8C%E5%88%86%E4%B9%8B%E8%BE%B9%E7%95%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><!-- build time:Sat Dec 14 2019 14:25:40 GMT+0800 (GMT+08:00) --><h2 id="整数区间二分"><a href="#整数区间二分" class="headerlink" title="整数区间二分"></a>整数区间二分</h2><h3 id="l-r当前均可行并记录答案时"><a href="#l-r当前均可行并记录答案时" class="headerlink" title="l,r当前均可行并记录答案时"></a>l,r当前均可行并记录答案时</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while(l&lt;=r)</span><br><span class="line">&#123;</span><br><span class="line">	int mid=(l+r)/2;</span><br><span class="line">	if(Check(mid))</span><br><span class="line">	&#123;</span><br><span class="line">		Ans=mid;</span><br><span class="line">		l=mid+1;//当min可行,防止死循环重复在mid一点,二分区间将mid排除</span><br><span class="line">	&#125;</span><br><span class="line">	else r=mid-1;//当mid不可行时,维护l,r当前均可行,二分区间将mid排除</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="l-r当前均可行并不记录答案时"><a href="#l-r当前均可行并不记录答案时" class="headerlink" title="l,r当前均可行并不记录答案时"></a>l,r当前均可行并不记录答案时</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while(l&lt;r)</span><br><span class="line">&#123;</span><br><span class="line">	int mid=(l+r)/2;</span><br><span class="line">	if(Check(mid))</span><br><span class="line">	&#123;</span><br><span class="line">		Ans=mid;</span><br><span class="line">		l=mid;//当min可行,为保存答案到最后,二分区间将mid排除</span><br><span class="line">	&#125;</span><br><span class="line">	else r=mid-1;//当mid不可行时,维护l,r当前均可行,二分区间将mid排除</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实数区间二分"><a href="#实数区间二分" class="headerlink" title="实数区间二分"></a>实数区间二分</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while(r-l&gt;DLT)//DLT为精度(如0.01)</span><br><span class="line">&#123;</span><br><span class="line">	double mid=(l+r)/2.0;</span><br><span class="line">	if(Check(mid))</span><br><span class="line">	&#123;</span><br><span class="line">		Ans=mid;</span><br><span class="line">		l=mid;</span><br><span class="line">	&#125;</span><br><span class="line">	else r=mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.sohu.com/a/243437962_100201031" target="_blank" rel="noopener">其实此文章写的甚是详细</a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
</search>
